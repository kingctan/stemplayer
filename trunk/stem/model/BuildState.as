package stem.model {	import flash.events.*;	import helper.*;	import stem.controllers.*; 	import stem.*; 		/**	* This is the Model build state where the XML is loaded and which interactions is going to happen is choose.	* This loaded into the model state at start up 	* @author Robin Petterd	*/	public class BuildState extends EventDispatcher 	{		private var state;		private var myBuilder; 		private var xmlSource = "data/people.xml"; 		private var _myType = "movieclip"; 				public var myEvents = new InteractionEvents();								public function BuildState (s,xml) {							xmlSource = xml; 				this.state = s; 								trace("n-just created the BuildState");						var myLoader = new LoaderXML(); 				myLoader.setSource = xmlSource; 				state.loadManager.add(myLoader);				myLoader.addEventListener(Event.COMPLETE, handleXMLComplete); 						}							/**			 * Process the xml set in the model data and choose which model and view to build 			 * @param	evt	An event with xml data 			 */			public function handleXMLComplete(evt:Event) { 		    					setData(evt); 				buildHelper(); 				chooseModel();				chooseReports(); 							}						private function buildHelper():void			{				var Helper:XMLList = state.myData.getHelp; 				state.myHelper.setData(Helper); //wierd should need the full path 							}						/**			 * This is where the reports are choosen and added to the Array of report in the Model 			 * MOD - add new reports types the using a simple factory that gets the type from the XML 			 */			private function chooseReports():void			{				var Reports:XMLList = state.myData.getReports; 				var found:Boolean = false; 								//Loop over each of the report types 				for (var i:Number = 0; i < Reports.length(); i++) {					trace(Reports.report[i]);															var report:String = Reports.report[i]; 					// choose which sort of report needs to be build 					switch(report) { 											case "scorm": 													trace("A scorm report needs to be built"); 							var reportObject = new ReportSCORM();														found = true; 														break; 					default:						trace("hmm some has gone wrong I don't know about that type of reporet"); 					} 								if (found) {						trace("adding a report"); 						reportObject.init(state.interactState.myScore) 						state.interactState.reports.push(reportObject);					}				}					}		 		 private function chooseModel():void		 {			/*now we need to see type of charater it and we make a different 			type of interaction depending on that*/ 									var type:String = state.myData.getType; 						switch(type) { 						case "image": 								trace("n-need to make an image type of interactions"); 								state.interactState = new Interaction("image", state); 				state.changingState = state.interactState;							break;							case "sound": 								trace("n-need to make an sound type of interactions"); 								state.interactState = new Interaction("sound", state); 				break; 			default:						case "sound": 								trace("n-need to make an video type of interactions"); 								state.interactState = new Interaction("video", state); 				break;												trace("hmm some has gone wrong I don't know about that type"); 			} 							state.changingState = state.interactState;								state.state = state.interactState; 								state.interactState.addEventListener(myEvents.HELP_UPDATE, state.myHelper.update); 												state.dispatchEvent(new Event(myEvents.MODEL_STATE_CHANGING)); 				state.dispatchEvent(new Event(myEvents.MODEL_STATE_CHANGED)); 										 }		 		 private function setData(evt:Event):void {						 //trace(evt.target.Data); 					state.myData.setMyData(evt.target.Data); 					}				public function get myType():String {			return _myType;		}				 	}	}